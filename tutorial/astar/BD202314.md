# 百度之星 BD202314 跑步

## 题目简述

若干个人，每个人有初始位置和初始速度。

当后面的人追上前面的人时，两个人会一起跑步，也就是跑的快的人会降低速度。

如果初始位置在一起，两个人就直接一起跑步。

## 解法
因为初始位置是乱序给的，所以要按照位置排序。

后面的人如果可以追上前面的人，则必需后面的人速度更快。

这里会陷入一个误区，“后面的人比前面的人更快”是“后面的人追上前面的人”的**充要条件**。

这是一个很经典的反例

```
2 3 1
```
虽然速度2的人追不上速度3的人，但是速度3的人一定可以追上速度1的人。此时就会变成：
```
2 1
```

则速度2的人就可以追上原本速度3的人。

后面的人要追上前面的人，只需要速度比前面最慢的快即可。

倒过来判断会很简单。
```cpp
#include <bits/stdc++.h>

using namespace std;

const int inf = INT_MAX / 2;
using pii = pair<int, int>;

int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    int n;
    cin >> n;
    vector<pii> a(n);
    for (auto &[p, v]: a) cin >> p >> v;
    sort(a.begin(), a.end(), [&](const pii &x, const pii &y) {
        if (x.first != y.first) return x.first < y.first;
        return x.second > y.second;
    });
    reverse(a.begin(), a.end());
    int res = 1, cnt = 0, lst_p = inf, min_v = inf;
    for (auto [p, v]: a) {
        if (p == lst_p) {
            cnt++;
            min_v = min(min_v, v);
        } else if (v > min_v) {
            cnt++;
        } else {
            min_v = v;
            cnt = 1;
        }
        res = max(res, cnt);
        lst_p = p;
    }
    cout << res;
    return 0;
}
```